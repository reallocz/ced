#include "window.h"
#include <locale.h>
#include <ncurses.h>
#include <stdio.h>
#include <assert.h>
#include "log.h"
#include <stdlib.h>
#include "defaults.h"

// A maximum of 4 windows allowed
#define WINDOW_DEFCAP 4
#define WINDOW_STATUSHEIGHT 2

/** Bring struct window* alias of id x into scope */
#define SW(alias, hWindow) \
	struct window* alias = _get_window(hWindow)

struct window {
	unsigned int id; // 0 for unused window
	int flags;

	// Curses
        WINDOW* nwin;

	// Buffer
	hBuffer buffer;	// 0 if no buffer set

	struct win_props props;
};


static struct {
	const char* tag;

	/*New ids are generated by incrementing this by 1*/
	unsigned int ids;
	unsigned int windowcap;
	struct window windows[WINDOW_DEFCAP];
} G;


void win_init()
{
	/// Initialize globals
	G.tag = "WINDOW";
	G.windowcap = WINDOW_DEFCAP;
	G.ids = 0;
	for(unsigned int i = 0; i < G.windowcap; ++i) {
		G.windows[i].id = WINDOW_DEFID;
	}
	log_l(G.tag, "Init success");
}


void win_exit()
{
}


static
unsigned int _generate_id()
{
	return ++G.ids;
}


static
struct window* _get_window(hWindow win)
{
	for(unsigned int i = 0; i < G.windowcap; ++i) {
		if(G.windows[i].id == win) {
			return &G.windows[i];
		}
	}
	log_ec("Available windows: ");
	for(unsigned int i = 0; i < G.windowcap; ++i) {
		if(G.windows[i].id != WINDOW_DEFID) {
			log_ec("%d, ", G.windows[i].id);
		}
	}
	log_ec("\n");
	log_fatal(G.tag, "%s: window not found: %d. See above"
			, __func__, win);
}

static
struct window* _get_free_window()
{
	for(unsigned int i = 0; i < G.windowcap; ++i) {
		if(G.windows[i].id == WINDOW_DEFID) {
			return &G.windows[i];
		}
	}
	log_fatal(G.tag, "%s: OUT OF WINDOWS!", __func__);
}


hWindow win_create(int y, int x, int rows, int cols)
{
	struct window* w = _get_free_window();

	w->id = _generate_id();
	w->flags = 0;
        w->nwin = NULL;
        w->nwin = newwin(rows, cols, y, x);
        assert(w->nwin);

	win_update(w->id);

	w->buffer = BUFFER_DEFID;

        keypad(w->nwin, TRUE);
        return w->id;
}


void win_destroy(hWindow win)
{
	SW(w, win);
	w->id = WINDOW_DEFID;
	delwin(w->nwin);
	log_l(G.tag, "Window destroyed: %d", win);
}



void win_update(hWindow win)
{
	SW(w, win);

	struct win_props props;

	// Dimensions
	{
		getyx(w->nwin, props.wy, props.wx);

		int width, height;
		getmaxyx(w->nwin, width, height);
		// 0 indexed
		props.wrows = width;
		props.wcols = height;
	}

	// statusline
	{
		props.sy = props.wrows - 1 - WINDOW_STATUSHEIGHT;
		props.sx = 0;
		props.swidth = props.wcols;
		props.sheight = WINDOW_STATUSHEIGHT;
	}

	// margin
	{
		props.my = 0;
		props.mx = 0;

		unsigned int lcount = 100;
		if(w->buffer != BUFFER_DEFID) {
			lcount = buf_get_linecount(w->buffer);
		}
		props.mwidth = lcount > 999 ? 4 : 3;
		props.mheight = props.wrows - 1 - WINDOW_STATUSHEIGHT;
	}

	// textarea
	{
		props.ty = 0;
		props.tx = props.mwidth;
		props.twidth = props.wcols - props.mwidth;
		props.theight = props.mheight;
	}

	w->props = props;

	// TODO Set window title based on the buffer

}



WINDOW* win_nwin(hWindow win)
{
	SW(w, win);
        return w->nwin;
}


int win_set_buffer(hWindow win, hBuffer buf)
{
	SW(w, win);
	log_l(G.tag, "(win:%d) buffer set: %d -> %d", win,
			w->buffer, buf);
	w->buffer = buf;
	win_update(win);
	return 0;
}


hBuffer win_get_buffer(hWindow win)
{
	SW(w, win);
	return w->buffer;
}


struct win_props win_get_props(hWindow win)
{
	SW(w, win);
	return w->props;
}


void win_set_cursor(hWindow win, int y, int x)
{
	SW(w, win);
	wmove(w->nwin, y, x);
}


void win_get_cursor(hWindow win, int* y, int* x)
{
	SW(w, win);
	int my, mx;
	getyx(w->nwin, my, mx);
	*y = my;
	*x = mx;
}


void win_pprint(hWindow win)
{
	SW(w, win);
	log_l(G.tag, "Window {");
	log_lc("id: %d, wy: %d, wx: %d, wrows: %d, wcols: %d\n",
			w->id, w->props.wy, w->props.wx, w->props.wrows, w->props.wcols);
	log_lc("sy: %d, sx: %d, swidth: %d, sheight: %d\n",
			w->props.sy, w->props.sx, w->props.swidth, w->props.sheight);
	log_lc("my: %d, mx: %d, mwidth: %d, mheight: %d\n",
			w->props.my, w->props.mx, w->props.mwidth, w->props.mheight);
	log_lc("ty: %d, tx: %d, twidth: %d, theight: %d\n}\n",
			w->props.ty, w->props.tx, w->props.twidth, w->props.theight);
}
