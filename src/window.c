#include "window.h"
#include <locale.h>
#include <ncurses.h>
#include <stdio.h>
#include <assert.h>
#include "log.h"
#include <stdlib.h>
#include "defaults.h"

// A maximum of 4 windows allowed
#define WINDOW_DEFCAP 4

/** Bring struct window* alias of id x into scope */
#define SW(alias, hWindow) \
	struct window* alias = _get_window(hWindow)

struct window {
	unsigned int id; // 0 for unused window
	int flags;

	// Curses
        WINDOW* nwin;
	// top left corner coords
	int y, x;
        int rows;
        int cols;

	// Buffers
	hBuffer buffer;	// 0 if no buffer set
};


static struct {
	const char* tag;

	/*New ids are generated by incrementing this by 1*/
	unsigned int ids;
	unsigned int windowcap;
	struct window windows[WINDOW_DEFCAP];
} G;


void win_init()
{
	/// Initialize globals
	G.tag = "WINDOW";
	G.windowcap = WINDOW_DEFCAP;
	G.ids = 0;
	for(unsigned int i = 0; i < G.windowcap; ++i) {
		G.windows[i].id = WINDOW_DEFID;
	}
	log_l(G.tag, "Init success");
}


void win_exit()
{
}


static
unsigned int _generate_id()
{
	return ++G.ids;
}

static
struct window* _get_window(hWindow win)
{
	for(unsigned int i = 0; i < G.windowcap; ++i) {
		if(G.windows[i].id == win) {
			return &G.windows[i];
		}
	}
	log_ec("Available windows: ");
	for(unsigned int i = 0; i < G.windowcap; ++i) {
		if(G.windows[i].id != WINDOW_DEFID) {
			log_ec("%d, ", G.windows[i].id);
		}
	}
	log_ec("\n");
	log_fatal(G.tag, "%s: window not found: %d. See above"
			, __func__, win);
}

static
struct window* _get_free_window()
{
	for(unsigned int i = 0; i < G.windowcap; ++i) {
		if(G.windows[i].id == WINDOW_DEFID) {
			return &G.windows[i];
		}
	}
	log_fatal(G.tag, "%s: OUT OF WINDOWS!", __func__);
}


hWindow win_create(int y, int x, int rows, int cols)
{
	struct window* w = _get_free_window();
	w->id = _generate_id();
	w->flags = 0;

        w->nwin = NULL;
        w->nwin = newwin(rows, cols, y, x);
        assert(w->nwin);
	int width, height;
	getmaxyx(w->nwin, width, height);
	w->rows = width - 1;	// rows are 0 indexed
	w->cols = height - 1;	// cols are 0 indexed
	w->y = y;
	w->x = x;

	w->buffer = 0;

        keypad(w->nwin, TRUE);
        return w->id;
}


void win_destroy(hWindow win)
{
	SW(w, win);
	w->id = WINDOW_DEFID;
	delwin(w->nwin);
	log_l(G.tag, "Window destroyed: %d", win);
}


int win_set_buffer(hWindow win, hBuffer buf)
{
	SW(w, win);
	log_l(G.tag, "(win:%d) buffer set: %d -> %d", win,
			w->buffer, buf);
	w->buffer = buf;
	return 0;
}

hBuffer win_get_buffer(hWindow win)
{
	SW(w, win);
	return w->buffer;
}



// Accessors

WINDOW* win_getnwin(hWindow win)
{
	SW(w, win);
        return w->nwin;
}


void win_getsize(hWindow win, int* rows, int* cols)
{
	SW(w, win);
	*rows = w->rows;
	*cols = w->cols;
}


void win_get_cursor(hWindow win, int* y, int* x)
{
	SW(w, win);
	int my, mx;
	getyx(w->nwin, my, mx);
	*y = my;
	*x = mx;
}

void win_set_cursor(hWindow win, int y, int x)
{
	SW(w, win);
	wmove(w->nwin, y, x);
}

void win_pprint(hWindow win)
{
	SW(w, win);
	log_l(G.tag, "Window {id=%d, y=%d, x=%d, rows=%d, cols=%d}", w->id, w->y, w->x, w->rows, w->cols);
}
